/*
bool read_command(std::string& cmd)
{
#if defined WIN32 || defined _WIN32
    static std::string cmd_buf;
    HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
    DWORD n = 0;
    INPUT_RECORD rec;
    if (!PeekConsoleInputA(hStdin, &rec, 1, &n) || n < 1) return false;
    if (rec.EventType != KEY_EVENT) {
        // drop non-key-event
        ReadConsoleInput(hStdin, &rec, 1, &n);
        return false;
    }
    // read unicode from console buffer
    WCHAR wBuf[256];
    wBuf[255] = 0;
    n = 255;
    if (!ReadConsoleW(hStdin, wBuf, n, &n, NULL)) {
        return false;
    }
    // convert to utf8
    int mbSize = WideCharToMultiByte(CP_UTF8, 0, wBuf, n, NULL, 0, NULL, NULL);
    if (mbSize == 0) {
        return false;
    }
    char *mbBuf = new char[mbSize+1];
    mbBuf[mbSize] = 0;
    WideCharToMultiByte(CP_UTF8, 0, wBuf, n, mbBuf, mbSize, NULL, NULL);
    cmd_buf += mbBuf;
    delete[] mbBuf;
    while (!cmd_buf.empty() && (cmd_buf[0] == 0x08 || cmd_buf[0] == '\r' || cmd_buf[0] == '\n' || cmd_buf[0] == 127))
        cmd_buf = cmd_buf.substr(1);
    for (size_t i=1; i<cmd_buf.length(); i++) {
        if (cmd_buf[i] != 0x08) continue;
        // backspace
        if ((cmd_buf[i-1] & 0b10000000) == 0) {
            cmd_buf.erase(i-1, 2);
            i--;
        } else if ((cmd_buf[i-2] & 0b11100000) == 0b11000000) {
            cmd_buf.erase(i-2, 3);
            i-=2;
        } else if ((cmd_buf[i-3] & 0b11110000) == 0b11100000) {
            cmd_buf.erase(i-3, 4);
            i-=3;
        } else if ((cmd_buf[i-4] & 0b11111000) == 0b11110000) {
            cmd_buf.erase(i-4, 5);
            i-=4;
        }
    }
    WCHAR *wBuf2 = new WCHAR[cmd_buf.length() + 1];
    wBuf2[0] = 0;
    MultiByteToWideChar(CP_UTF8, 0, cmd_buf.c_str(), cmd_buf.length() + 1, wBuf2, cmd_buf.length() + 1);
    wprintf(L"\r                                        \r%ls", wBuf2);
    delete[] wBuf2;
    size_t p = cmd_buf.find('\r');
    if (p != cmd_buf.npos) {
        cmd = cmd_buf.substr(0, p);
        cmd_buf = cmd_buf.substr(p+1);
        printf("\n");
    }
    while (!cmd.empty() && (cmd.back() == '\n' || cmd.back() == '\r')) cmd.pop_back();
    return !cmd.empty();
#endif
}
*/

/*

#define WSWRAP_NO_SSL

void ap_clear_items()
{
    std::cout << "AP: ap_clear_items" << std::endl;
}

void ap_receive_item(int item_id, bool notify_player)
{
    std::cout << "AP: ap_receive_item " << item_id << " , " << notify_player << std::endl;
}

void ap_location_checked(int location_id)
{
    std::cout << "AP: ap_location_checked " << location_id << std::endl;
    //
}

void ap_kill_player()
{
    std::cout << "AP: ap_kill_player " << std::endl;
    // TODO: Kill player
}

void test_archipelago()
{
    AP_NetworkVersion client_version = {0,3,8};
    AP_SetClientVersion(&client_version);

    AP_Init("archipelago.gg:65512", "Rogue Legacy", "Dinopony", "");
    AP_Start();

    AP_SetItemClearCallback(&ap_clear_items);
    AP_SetItemRecvCallback(&ap_receive_item);
    AP_SetLocationCheckedCallback(&ap_location_checked);
    AP_SetDeathLinkRecvCallback(&ap_kill_player);

    // TODO: Create a patched ROM using the patching JSON

    // TODO: Wait for Retroarch connection
    // TODO: Check if the ROM is the right one

    // - Open a handle on module "genesis_plus_gx_libretro.dll"
    // - Find occurence of `85 C9 74 ?? 83 F9 02 B8 00 00 00 00 48 0F 44 05 ?? ?? ?? ?? C3`
    //      - Look for `85 C9 74 ?? 31 C0 83 F9 02 48 0F 44 05 ?? ?? ?? ?? C3` if it cannot be found
    // - Read the value at '?? ?? ?? ??', add it to (address of that value + 4)
    // - This is the address of the 68k RAM
    // - Use `ReadProcessMemory` to read 68k RAM, and `WriteProcessMemory` to write into it
}

*/

/*
void create_game()
{
    if (game) delete game;
    game = nullptr;

    printf("Instantiating \"%s\" game...\n", GAME::Name);
    game = new GAME(snes);
    game->set_game_started_handler([]() {
        game->clear_cache(); // is this good enough?
        if (ap && ap->get_state() > APClient::State::ROOM_INFO) {
            // compare seed & slot and disconnect if they do not match
            if (!game->get_seed().empty() &&
                strncmp(game->get_seed().c_str(), ap->get_seed().c_str(), GAME::MAX_SEED_LENGTH) != 0)
            {
                bad_seed(ap->get_seed(), game->get_seed());
                ap->reset();
                return;
            }
            else if (game->get_slot() != ap->get_slot())
            {
                printf("Slot changed, disconnecting.\n");
                ap->reset();
                return;
            }
            else if (game->get_deathlink() != game->want_deathlink()) {
                std::list<std::string> tags;
                game->set_deathlink(game->want_deathlink());
                if (game->get_deathlink()) tags.push_back("DeathLink");
                ap->ConnectUpdate(false, 0, true, {"DeathLink"});
            }
        }
        if (ap && ap->get_state() == APClient::State::ROOM_INFO) {
            if (!game->get_seed().empty() &&
                strncmp(game->get_seed().c_str(), ap->get_seed().c_str(), GAME::MAX_SEED_LENGTH) != 0)
            {
                bad_seed(ap->get_seed(), game->get_seed());
                return;
            }
            else
            {
                std::list<std::string> tags;
                game->set_deathlink(game->want_deathlink());
                if (game->get_deathlink()) tags.push_back("DeathLink");
                ap->ConnectSlot(game->get_slot(), password, game->get_items_handling(), tags, VERSION_TUPLE);
                ap_connect_sent = true; // TODO: move to APClient::State ?
            }
        }
    });
    game->set_game_stopped_handler([]() {
    });
    game->set_game_joined_handler([]() {
        // TODO: cache in Game instead of ap->sync()?
        if (ap && ap->get_state() == APClient::State::SLOT_CONNECTED) {
            ap->Sync();
        }
    });
    game->set_game_left_handler([]() {
    });
    game->set_game_finished_handler([]() {
        printf("Game finished!\n");
        if (ap) ap->StatusUpdate(APClient::ClientStatus::GOAL);
    });
    game->set_locations_checked_handler([](std::list<int64_t> locations) {
        if (ap) ap->LocationChecks(locations);
    });
    game->set_locations_scouted_handler([](std::list<int64_t> locations) {
        if (ap) ap->LocationScouts(locations);
    });
    game->set_death_handler([]() {
        if (!ap) return;
        deathtime = ap->get_server_time();
        json data{
                {"time", deathtime}, // TODO: insert time here
                {"cause", "Evermore."},
                {"source", ap->get_slot()},
        };
        ap->Bounce(data, {}, {}, {"DeathLink"});
    });
}
*/
